{"version":3,"file":"OggDemuxer.js","sourceRoot":"","sources":["../../play-audio/ogg/OggDemuxer.ts"],"names":[],"mappings":";;;AAAA,mCAA+C;AAE/C,MAAM,oBAAoB,GAAG,EAAE,CAAC;AAChC,MAAM,WAAW,GAAG,CAAC,CAAC;AAEtB,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACxC,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AAC1C,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AAU1C,MAAa,UAAW,SAAQ,eAAM;IAKlC,YAAY,OAAuB;QAC/B,KAAK,CAAC,OAAO,CAAC,CAAC;IACnB,CAAC;IAEM,KAAK,KAAI,CAAC;IAEV,MAAM,CAAC,KAAa,EAAE,QAAwB,EAAE,IAA6B;QAChF,IAAI,IAAI,CAAC,SAAS,EAAE;YAChB,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;YAC/C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;SAC9B;QAED,OAAO,IAAI,EAAE;YACT,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YACvC,IAAI,MAAM,EAAE;gBACR,IAAI,MAAM,YAAY,KAAK;oBAAE,IAAI,CAAC,MAAM,CAAC,CAAC;;oBACrC,KAAK,GAAG,MAAM,CAAC;aACvB;;gBAAM,MAAM;SAChB;QAED,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;QAC1B,IAAI,EAAE,CAAC;IACX,CAAC;IAEO,WAAW,CAAC,KAAa;QAC7B,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAChB,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAC5C,IAAI,CAAC,WAAW;gBAAE,OAAO,KAAK,CAAC;YAC/B,IAAI,WAAW,YAAY,KAAK;gBAAE,OAAO,WAAW,CAAC;YACrD,OAAO,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;SACxC;;YAAM,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IAC1C,CAAC;IAEO,WAAW,CAAC,KAAa;QAC7B,IAAI,CAAC,IAAI,CAAC,QAAQ;YAAE,OAAO,KAAK,CAAC;QACjC,IAAI,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS;YAAE,OAAO,KAAK,CAAC;QAEzD,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE;YACpC,MAAM,OAAO,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC,CAAC;YACjD,IAAI,IAAI,CAAC,SAAS,EAAE;gBAChB,IAAI,IAAI,IAAI,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;oBAAE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;;oBACrF,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aAC3B;iBAAM,IAAI,OAAO,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE;gBACrD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;gBAC3B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC;aAC5B;;gBAAM,OAAO,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;YACjD,KAAK,IAAI,IAAI,CAAC;SACjB;QACD,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;QAC1B,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;IAC9B,CAAC;IAEO,WAAW,CAAC,KAAa;QAC7B,IAAI,KAAK,CAAC,MAAM,GAAG,oBAAoB;YAAE,OAAO,KAAK,CAAC;QACtD,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;YAAE,OAAO,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;QAClG,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,WAAW;YAAE,OAAO,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAE3F,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE;YAAE,OAAO,KAAK,CAAC;QACpC,MAAM,YAAY,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;QACzC,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,GAAG,YAAY;YAAE,OAAO,KAAK,CAAC;QACnD,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,GAAG,YAAY,CAAC,CAAC;QAEjD,MAAM,KAAK,GAAa,EAAE,CAAC;QAC3B,IAAI,SAAS,GAAG,CAAC,CAAC;QAElB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,GAAI;YAChC,IAAI,IAAI,GAAG,CAAC,CAAC;YACb,IAAI,CAAC,GAAG,GAAG,CAAC;YACZ,OAAO,CAAC,KAAK,GAAG,EAAE;gBACd,IAAI,CAAC,IAAI,KAAK,CAAC,MAAM;oBAAE,OAAO,KAAK,CAAC;gBACpC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACvB,CAAC,EAAE,CAAC;gBACJ,IAAI,IAAI,CAAC,CAAC;aACb;YACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACjB,SAAS,IAAI,IAAI,CAAC;SACrB;QACD,IAAI,CAAC,QAAQ,GAAG;YACZ,KAAK,EAAE,KAAK;YACZ,SAAS,EAAE,SAAS;YACpB,YAAY,EAAE,YAAY;SAC7B,CAAC;QACF,OAAO,KAAK,CAAC,KAAK,CAAC,EAAE,GAAG,YAAY,CAAC,CAAC;IAC1C,CAAC;IAEM,QAAQ,CAAC,GAAiB,EAAE,QAAuC;QACtE,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,QAAQ,CAAC,GAAG,CAAC,CAAC;IAClB,CAAC;IAEM,MAAM,CAAC,QAAiC;QAC3C,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,QAAQ,EAAE,CAAC;IACf,CAAC;IAEM,QAAQ;QACX,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;IAC9B,CAAC;CACJ;AA3GD,gCA2GC","sourcesContent":["import { Duplex, DuplexOptions } from 'stream';\n\nconst OGG_PAGE_HEADER_SIZE = 26;\nconst OGG_VERSION = 0;\n\nconst OGGS_HEADER = Buffer.from('OggS');\nconst OPUS_HEAD = Buffer.from('OpusHead');\nconst OPUS_TAGS = Buffer.from('OpusTags');\n\ninterface OggHeader {\n    pageSegments: number;\n    sizes: number[];\n    totalSize: number;\n}\n\ntype ParseResult = Error | Buffer | false;\n\nexport class OggDemuxer extends Duplex {\n    private remaining?: Buffer;\n    private opus_head?: Buffer;\n    private ogg_head?: OggHeader;\n\n    constructor(options?: DuplexOptions) {\n        super(options);\n    }\n\n    public _read() {}\n\n    public _write(chunk: Buffer, encoding: BufferEncoding, done: (error?: Error) => void) {\n        if (this.remaining) {\n            chunk = Buffer.concat([this.remaining, chunk]);\n            this.remaining = undefined;\n        }\n\n        while (true) {\n            const result = this.readOggPage(chunk);\n            if (result) {\n                if (result instanceof Error) done(result);\n                else chunk = result;\n            } else break;\n        }\n\n        this.remaining = chunk;\n        this.ogg_head = undefined;\n        done();\n    }\n\n    private readOggPage(chunk: Buffer): ParseResult {\n        if (!this.ogg_head) {\n            const result_head = this.readOggHead(chunk);\n            if (!result_head) return false;\n            if (result_head instanceof Error) return result_head;\n            return this.readOggData(result_head);\n        } else return this.readOggData(chunk);\n    }\n\n    private readOggData(chunk: Buffer): ParseResult {\n        if (!this.ogg_head) return false;\n        if (chunk.length < this.ogg_head.totalSize) return false;\n\n        let start = 0;\n        for (const size of this.ogg_head.sizes) {\n            const segment = chunk.slice(start, start + size);\n            if (this.opus_head) {\n                if (size >= 8 && segment.compare(OPUS_TAGS, 0, 8, 0, 8) === 0) this.emit('tags', segment);\n                else this.push(segment);\n            } else if (segment.compare(OPUS_HEAD, 0, 8, 0, 8) === 0) {\n                this.emit('head', segment);\n                this.opus_head = segment;\n            } else return new Error('Unknown Segment Found');\n            start += size;\n        }\n        this.ogg_head = undefined;\n        return chunk.slice(start);\n    }\n\n    private readOggHead(chunk: Buffer): ParseResult {\n        if (chunk.length < OGG_PAGE_HEADER_SIZE) return false;\n        if (chunk.compare(OGGS_HEADER, 0, 4, 0, 4) !== 0) return new Error('Capture Pattern is not OggS');\n        if (chunk.readUInt8(4) !== OGG_VERSION) return new Error(`OGG version is not equal to 0.`);\n\n        if (chunk.length < 27) return false;\n        const pageSegments = chunk.readUInt8(26);\n        if (chunk.length < 27 + pageSegments) return false;\n        const table = chunk.slice(27, 27 + pageSegments);\n\n        const sizes: number[] = [];\n        let totalSize = 0;\n\n        for (let i = 0; i < pageSegments; ) {\n            let size = 0;\n            let x = 255;\n            while (x === 255) {\n                if (i >= table.length) return false;\n                x = table.readUInt8(i);\n                i++;\n                size += x;\n            }\n            sizes.push(size);\n            totalSize += size;\n        }\n        this.ogg_head = {\n            sizes: sizes,\n            totalSize: totalSize,\n            pageSegments: pageSegments\n        };\n        return chunk.slice(27 + pageSegments);\n    }\n\n    public _destroy(err: Error | null, callback: (error: Error | null) => void): void {\n        this._cleanup();\n        callback(err);\n    }\n\n    public _final(callback: (error?: Error) => void): void {\n        this._cleanup();\n        callback();\n    }\n\n    public _cleanup() {\n        this.remaining = undefined;\n        this.opus_head = undefined;\n        this.ogg_head = undefined;\n    }\n}\n"]}