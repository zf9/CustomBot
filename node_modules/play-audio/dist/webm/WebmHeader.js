"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebmHeader = void 0;
class WebmHeader {
    constructor() {
        this.ebml = {};
        this.segment = {};
        this.audioTrack = -1;
    }
    parse(ebmlID, chunk) {
        switch (ebmlID.name) {
            case "ebml":
                this.ebml = {};
                break;
            case "ebmlVersion":
                if (ebmlID.return)
                    this.ebml.version = ebmlID.return(chunk);
                break;
            case "ebmlReadVersion":
                if (ebmlID.return)
                    this.ebml.readVersion = ebmlID.return(chunk);
                break;
            case "ebmlMaxIDLength":
                if (ebmlID.return)
                    this.ebml.maxIDLength = ebmlID.return(chunk);
                break;
            case "ebmlMaxSizeLength":
                if (ebmlID.return)
                    this.ebml.maxSizeWidth = ebmlID.return(chunk);
                break;
            case "docType":
                if (ebmlID.return) {
                    const doctype = ebmlID.return(chunk);
                    if (doctype !== 'webm')
                        return new Error("This is not a Webm Stream. [ DocType !== webm ]");
                    else
                        this.ebml.docType = doctype;
                }
                break;
            case "docTypeVersion":
                if (ebmlID.return)
                    this.ebml.docTypeVersion = ebmlID.return(chunk);
                break;
            case "docTypeReadVersion":
                if (ebmlID.return)
                    this.ebml.docTypeReadVersion = ebmlID.return(chunk);
                break;
            case "segment":
                this.segment = {};
                break;
            case "seekHead":
                this.segment.seekHead = [];
                break;
            case "seekPosition":
                if (ebmlID.return)
                    this.segment.seekHead.push({ position: ebmlID.return(chunk) });
                break;
            case "info":
                this.segment.info = {};
                break;
            case "duration":
                if (ebmlID.return)
                    this.segment.info.duration = ebmlID.return(chunk);
                break;
            case "muxingApp":
                if (ebmlID.return)
                    this.segment.info.muxingApp = ebmlID.return(chunk);
                break;
            case "writingApp":
                if (ebmlID.return)
                    this.segment.info.writingApp = ebmlID.return(chunk);
                break;
            case "cluster":
                this.segment.cluster = {};
                break;
            case "clusterTimecode":
                if (ebmlID.return)
                    this.segment.cluster.time = ebmlID.return(chunk);
                break;
            case "simpleBlock":
                break;
            case "tracks":
                this.segment.tracks = [];
                break;
            case "trackEntry":
                this.segment.tracks.push({});
                break;
            case "trackNumber":
                if (ebmlID.return)
                    this.segment.tracks[this.segment.tracks.length - 1].trackNumber = ebmlID.return(chunk);
                break;
            case "trackType":
                if (ebmlID.return) {
                    const type = ebmlID.return(chunk);
                    if (type === 2)
                        this.audioTrack = this.segment.tracks.length - 1;
                    this.segment.tracks[this.segment.tracks.length - 1].trackType = type;
                }
                break;
            case "codecID":
                if (ebmlID.return) {
                    const codec = ebmlID.return(chunk);
                    if (codec !== 'A_OPUS' && this.segment.tracks[this.segment.tracks.length - 1].trackType === 2)
                        return new Error("Audio Codec is not OPUS");
                    this.segment.tracks[this.segment.tracks.length - 1].codecID = codec;
                }
                break;
            case "audio":
                this.segment.tracks[this.segment.tracks.length - 1].audio = {};
                break;
            case "samplingFrequency":
                if (ebmlID.return)
                    this.segment.tracks[this.segment.tracks.length - 1].audio.rate = ebmlID.return(chunk);
                break;
            case "channels":
                if (ebmlID.return)
                    this.segment.tracks[this.segment.tracks.length - 1].audio.channels = ebmlID.return(chunk);
                break;
            case "bitDepth":
                if (ebmlID.return)
                    this.segment.tracks[this.segment.tracks.length - 1].audio.bitDepth = ebmlID.return(chunk);
                break;
            case "cues":
                this.segment.cues = [];
                break;
            case "cuePoint":
                this.segment.cues.push({});
                break;
            case "cueTime":
                if (ebmlID.return)
                    this.segment.cues[this.segment.cues.length - 1].time = ebmlID.return(chunk);
                break;
            case "cueTrack":
                if (ebmlID.return)
                    this.segment.cues[this.segment.cues.length - 1].track = ebmlID.return(chunk);
                break;
            case "cueClusterPosition":
                if (ebmlID.return)
                    this.segment.cues[this.segment.cues.length - 1].position = ebmlID.return(chunk);
                break;
            default:
                break;
        }
    }
}
exports.WebmHeader = WebmHeader;
//# sourceMappingURL=WebmHeader.js.map