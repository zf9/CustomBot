"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebmDemuxer = void 0;
const stream_1 = require("stream");
const WebmConstant_1 = require("./WebmConstant");
const WebmHeader_1 = require("./WebmHeader");
class WebmDemuxer extends stream_1.Duplex {
    constructor(options) {
        super(options);
        this.cursor = 0;
        this.header = new WebmHeader_1.WebmHeader();
        this.headfound = false;
        this.data_length = 0;
        this.data_size = 0;
    }
    get vint_length() {
        let i = 0;
        for (; i < 8; i++) {
            if ((1 << (7 - i)) & this.chunk[this.cursor])
                break;
        }
        i++;
        return i;
    }
    get vint_value() {
        if (!this.chunk)
            return false;
        const length = this.vint_length;
        if (this.chunk.length < this.cursor + length)
            return false;
        let value = this.chunk[this.cursor] & ((1 << (8 - length)) - 1);
        for (let i = this.cursor + 1; i < this.cursor + length; i++)
            value = (value << 8) + this.chunk[i];
        this.data_size = length;
        this.data_length = value;
        return true;
    }
    cleanup() {
        this.cursor = 0;
        this.chunk = undefined;
        this.remaining = undefined;
    }
    _read() { }
    _write(chunk, _, done) {
        if (this.remaining) {
            this.chunk = Buffer.concat([this.remaining, chunk]);
            this.remaining = undefined;
        }
        else
            this.chunk = chunk;
        const tag = this.readTag();
        if (tag instanceof Error)
            done(tag);
        else
            done();
    }
    readTag() {
        if (!this.chunk)
            return new Error("Chunk is missing");
        while (this.chunk.length > this.cursor) {
            const oldCursor = this.cursor;
            const id = this.vint_length;
            if (this.chunk.length < this.cursor + id)
                break;
            const ebmlID = this.parseEbmlID(this.chunk.slice(this.cursor, this.cursor + id).toString('hex'));
            this.cursor += id;
            const vint = this.vint_value;
            if (!vint) {
                this.cursor = oldCursor;
                break;
            }
            if (!ebmlID) {
                this.cursor += this.data_size + this.data_length;
                continue;
            }
            if (!this.headfound) {
                if (ebmlID.name === "ebml")
                    this.headfound = true;
                else
                    return new Error("Failed to find EBML ID at start of stream.");
            }
            const data = this.chunk.slice(this.cursor + this.data_size, this.cursor + this.data_size + this.data_length);
            const parse = this.header.parse(ebmlID, data);
            if (parse instanceof Error)
                return parse;
            if (ebmlID.type === WebmConstant_1.DataType.master) {
                this.cursor += this.data_size;
                continue;
            }
            if (this.chunk.length < this.cursor + this.data_size + this.data_length) {
                this.cursor = oldCursor;
                break;
            }
            else
                this.cursor += this.data_size + this.data_length;
            if (ebmlID.name === 'simpleBlock') {
                const track = this.header.segment.tracks[this.header.audioTrack];
                if (!track || track.trackType !== 2)
                    return new Error("No audio Track in this webm file.");
                if ((data[0] & 0xf) === track.trackNumber)
                    this.push(data.slice(4));
            }
        }
        this.remaining = this.chunk.slice(this.cursor);
        this.cursor = 0;
    }
    parseEbmlID(ebmlID) {
        if (Object.keys(WebmConstant_1.WebmElements).includes(ebmlID))
            return WebmConstant_1.WebmElements[ebmlID];
        else
            return false;
    }
    _destroy(error, callback) {
        this.cleanup();
        callback(error);
    }
    _final(callback) {
        this.cleanup();
        callback();
    }
}
exports.WebmDemuxer = WebmDemuxer;
//# sourceMappingURL=WebmDemuxer.js.map